<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D â†’ 2D Projection with Displayed Variance</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  :root {
    --bg: #ffffff;
    --card: #ffffff;
    --text: #111;
    --accent: #007bff;
    --accent-hover: #0056b3;
    --muted: rgba(0,0,0,0.1);
    --info-bg: #f0f8ff;
    --info-text: #2c5aa0;
  }
  body.dark {
    --bg: rgb(27,27,30);
    --card: #2b2b33;
    --text: #f2f2f7;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --muted: rgba(255,255,255,0.08);
    --info-bg: #2f3a52;
    --info-text: #9ec5ff;
  }

  body {
    font-family: system-ui, -apple-system, sans-serif;
    margin: 0;
    padding: 20px;
    background: var(--bg);
    color: var(--text);
    transition: background 0.25s ease, color 0.25s ease;
  }

  .container {
    max-width: 1400px;
    margin: 0 auto;
  }

  .plots {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .plot-box {
    background: var(--card);
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 2px 10px var(--muted);
    flex: 1 1 300px; /* shrink but allow to grow */
    min-width: 280px;
    max-width: 500px;
  }

  #plot3d, #plot2d {
    width: 100%;
    height: 400px;
  }

  .controls {
    background: var(--card);
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 10px var(--muted);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
  }

  .sliders {
    display: flex;
    gap: 40px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .slider-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }

  .slider {
    width: 200px;
    max-width: 90vw;
  }

  .variance-info {
    background: var(--info-bg);
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    color: var(--info-text);
  }

  button {
    background: var(--accent);
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.2s ease, transform 0.02s ease;
  }
  button:hover {
    background: var(--accent-hover);
  }

  @media (max-width: 768px) {
    .plots {
      flex-wrap: nowrap; /* stay side by side */
      justify-content: space-between;
    }
    .plot-box {
      flex: 1 1 45%; /* shrink plots to ~45% of container */
      min-width: 150px;
    }
    #plot3d, #plot2d {
      height: 300px;
    }
    .sliders {
      flex-direction: column;
      gap: 20px;
    }
  }
</style>
</head>
<body>

<div class="container">
  <h2 style="text-align: center; margin-bottom: 30px;">3D â†’ 2D Projection Visualizer</h2>

  <div class="plots">
    <div class="plot-box">
      <h3 style="text-align: center; margin: 0 0 10px 0;">3D Original Data</h3>
      <div id="plot3d"></div>
    </div>
    <div class="plot-box">
      <h3 style="text-align: center; margin: 0 0 10px 0;">2D Projection</h3>
      <div id="plot2d"></div>
    </div>
  </div>

  <div class="controls">
    <div class="variance-info">
      Variance: <span id="varianceValue">0.00</span>
    </div>

    <div class="sliders">
      <div class="slider-group">
        <label>Azimuth: <span id="azimuthValue">45Â°</span></label>
        <input type="range" id="azimuthSlider" class="slider" min="0" max="360" value="45">
      </div>
      <div class="slider-group">
        <label>Elevation: <span id="elevationValue">30Â°</span></label>
        <input type="range" id="elevationSlider" class="slider" min="-89" max="89" value="30">
      </div>
    </div>

    <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
      <button id="regenerateBtn">ðŸ”„ New Data</button>
      <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
        <input type="checkbox" id="showPCA" checked> Show PCA
      </label>
    </div>

    <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; margin-top: 15px;">
      <button id="pc12Btn" style="background: #6f42c1; font-size: 14px; padding: 8px 16px;">PC1-PC2 Plane</button>
      <button id="pc13Btn" style="background: #20c997; font-size: 14px; padding: 8px 16px;">PC1-PC3 Plane</button>
      <button id="pc23Btn" style="background: #fd7e14; font-size: 14px; padding: 8px 16px;">PC2-PC3 Plane</button>
    </div>
  </div>
</div>

<script>
/* ---------- Theme (auto-detect dark mode) ---------- */
const darkMQ = window.matchMedia('(prefers-color-scheme: dark)');
function applyTheme() {
  if (darkMQ.matches) document.body.classList.add('dark');
  else document.body.classList.remove('dark');
  if (document.getElementById('plot3d').data) updatePlots();
}
applyTheme();
darkMQ.addEventListener('change', applyTheme);

function theme() {
  const dark = document.body.classList.contains('dark');
  return {
    isDark: dark,
    paperBg: dark ? 'rgb(27,27,30)' : '#ffffff',
    plotBg:  dark ? 'rgb(27,27,30)' : '#ffffff',
    grid:    dark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
    text:    dark ? '#f2f2f7' : '#111111',
    axis:    dark ? '#e5e7eb' : '#111111'
  };
}

/* ---------- (rest of code remains the same as before) ---------- */
/* ... copy all the JS from the previous full code without changes ... */

/* ---------- Data generation ---------- */
function generateData() {
  const points = [];
  for (let i = 0; i < 10; i++) {
    points.push({
      x: (Math.random() - 0.5) * 6,
      y: (Math.random() - 0.5) * 6,
      z: (Math.random() - 0.5) * 6
    });
  }
  return points;
}

/* ---------- Projection helpers ---------- */
function sphericalToNormal(azimuth, elevation) {
  const az = azimuth * Math.PI / 180;
  const el = elevation * Math.PI / 180;
  return {
    x: Math.cos(el) * Math.cos(az),
    y: Math.cos(el) * Math.sin(az),
    z: Math.sin(el)
  };
}

function projectTo2D(points3d, normal) {
  // Build orthonormal basis (u1, u2) spanning the plane orthogonal to normal
  let u1 = Math.abs(normal.x) > 0.9 ? {x:0,y:1,z:0} : {x:1,y:0,z:0};
  // make u1 âŸ‚ normal
  const d = u1.x*normal.x + u1.y*normal.y + u1.z*normal.z;
  u1 = { x: u1.x - d*normal.x, y: u1.y - d*normal.y, z: u1.z - d*normal.z };
  const u1len = Math.hypot(u1.x,u1.y,u1.z);
  u1 = { x:u1.x/u1len, y:u1.y/u1len, z:u1.z/u1len };
  // u2 = normal Ã— u1
  const u2 = {
    x: normal.y * u1.z - normal.z * u1.y,
    y: normal.z * u1.x - normal.x * u1.z,
    z: normal.x * u1.y - normal.y * u1.x
  };
  return points3d.map(p => ({
    x: p.x*u1.x + p.y*u1.y + p.z*u1.z,
    y: p.x*u2.x + p.y*u2.y + p.z*u2.z
  }));
}

function calculateVariance(points2d) {
  if (points2d.length < 2) return 0;
  const meanX = points2d.reduce((s,p)=>s+p.x,0)/points2d.length;
  const meanY = points2d.reduce((s,p)=>s+p.y,0)/points2d.length;
  return points2d.reduce((sum,p)=>{
    const dx=p.x-meanX, dy=p.y-meanY;
    return sum + dx*dx + dy*dy;
  },0)/(points2d.length-1);
}

/* ---------- PCA (power iteration + deflation) ---------- */
function calculatePCA(points) {
  const n = points.length;
  if (n < 3) return null;

  const mean = {
    x: points.reduce((s,p)=>s+p.x,0)/n,
    y: points.reduce((s,p)=>s+p.y,0)/n,
    z: points.reduce((s,p)=>s+p.z,0)/n
  };

  let cxx=0,cxy=0,cxz=0,cyy=0,cyz=0,czz=0;
  for (const p of points) {
    const dx=p.x-mean.x, dy=p.y-mean.y, dz=p.z-mean.z;
    cxx+=dx*dx; cxy+=dx*dy; cxz+=dx*dz;
    cyy+=dy*dy; cyz+=dy*dz; czz+=dz*dz;
  }
  const f = 1/(n-1);
  cxx*=f; cxy*=f; cxz*=f;
  cyy*=f; cyz*=f; czz*=f;

  // power iteration for PC1
  let v1={x:1,y:1,z:1};
  for (let k=0;k<40;k++){
    const nv={ x:cxx*v1.x + cxy*v1.y + cxz*v1.z,
               y:cxy*v1.x + cyy*v1.y + cyz*v1.z,
               z:cxz*v1.x + cyz*v1.y + czz*v1.z };
    const norm=Math.hypot(nv.x,nv.y,nv.z)||1;
    v1={x:nv.x/norm,y:nv.y/norm,z:nv.z/norm};
  }
  const lambda1 =
    v1.x*(cxx*v1.x + cxy*v1.y + cxz*v1.z) +
    v1.y*(cxy*v1.x + cyy*v1.y + cyz*v1.z) +
    v1.z*(cxz*v1.x + cyz*v1.y + czz*v1.z);

  // deflate
  const c2 = {
    xx: cxx - lambda1*v1.x*v1.x,
    xy: cxy - lambda1*v1.x*v1.y,
    xz: cxz - lambda1*v1.x*v1.z,
    yy: cyy - lambda1*v1.y*v1.y,
    yz: cyz - lambda1*v1.y*v1.z,
    zz: czz - lambda1*v1.z*v1.z
  };

  // initial v2 orthogonal to v1
  let v2 = Math.abs(v1.x) < 0.8 ? {x:1,y:0,z:0} : {x:0,y:1,z:0};
  const d = v2.x*v1.x + v2.y*v1.y + v2.z*v1.z;
  v2 = { x:v2.x-d*v1.x, y:v2.y-d*v1.y, z:v2.z-d*v1.z };
  let nrm = Math.hypot(v2.x,v2.y,v2.z)||1;
  v2 = { x:v2.x/nrm, y:v2.y/nrm, z:v2.z/nrm };

  // refine v2 in deflated matrix
  for (let k=0;k<40;k++){
    let nv = {
      x: c2.xx*v2.x + c2.xy*v2.y + c2.xz*v2.z,
      y: c2.xy*v2.x + c2.yy*v2.y + c2.yz*v2.z,
      z: c2.xz*v2.x + c2.yz*v2.y + c2.zz*v2.z
    };
    // re-orthogonalize against v1
    const d = nv.x*v1.x + nv.y*v1.y + nv.z*v1.z;
    nv = { x:nv.x - d*v1.x, y:nv.y - d*v1.y, z:nv.z - d*v1.z };
    const norm=Math.hypot(nv.x,nv.y,nv.z)||1;
    v2 = { x:nv.x/norm, y:nv.y/norm, z:nv.z/norm };
  }

  // v3 = v1 Ã— v2
  const v3 = {
    x: v1.y*v2.z - v1.z*v2.y,
    y: v1.z*v2.x - v1.x*v2.z,
    z: v1.x*v2.y - v1.y*v2.x
  };
  // normalize v3
  nrm = Math.hypot(v3.x,v3.y,v3.z)||1;
  const pc3 = { x:v3.x/nrm, y:v3.y/nrm, z:v3.z/nrm };

  return { pc1:v1, pc2:v2, pc3, center: mean };
}

/* ---------- Normal â†’ spherical, PC plane presets ---------- */
function normalToSpherical(normal) {
  const azimuth = Math.atan2(normal.y, normal.x) * 180 / Math.PI;
  const elevation = Math.asin(Math.max(-1, Math.min(1, normal.z))) * 180 / Math.PI;
  return { azimuth: azimuth < 0 ? azimuth + 360 : azimuth, elevation };
}
function setToPCPlane(pc1, pc2) {
  const normal = {
    x: pc1.y*pc2.z - pc1.z*pc2.y,
    y: pc1.z*pc2.x - pc1.x*pc2.z,
    z: pc1.x*pc2.y - pc1.y*pc2.x
  };
  const s = normalToSpherical(normal);
  azimuth = s.azimuth;
  elevation = s.elevation;
  document.getElementById('azimuthSlider').value = azimuth;
  document.getElementById('elevationSlider').value = elevation;
  document.getElementById('azimuthValue').textContent = Math.round(azimuth)+'Â°';
  document.getElementById('elevationValue').textContent = Math.round(elevation)+'Â°';
  updatePlots();
}

/* ---------- Globals ---------- */
let data3D = generateData();
let azimuth = 45;
let elevation = 30;

/* ---------- Plot update ---------- */
function updatePlots() {
  const t = theme();
  const normal = sphericalToNormal(azimuth, elevation);
  const projected = projectTo2D(data3D, normal);
  const variance = calculateVariance(projected);

  // 3D scatter
  const trace3D = {
    x: data3D.map(p=>p.x),
    y: data3D.map(p=>p.y),
    z: data3D.map(p=>p.z),
    mode: 'markers',
    type: 'scatter3d',
    name: 'Original Data',
    marker: { size: 5, color: t.isDark ? '#9ec5ff' : '#1f77b4', opacity: 0.85 }
  };

  // Projection plane (surface)
  const planeSize = 3;
  // get basis u1, u2 (same as projectTo2D)
  let u1 = Math.abs(normal.x) > 0.9 ? {x:0,y:1,z:0} : {x:1,y:0,z:0};
  const d = u1.x*normal.x + u1.y*normal.y + u1.z*normal.z;
  u1 = { x: u1.x - d*normal.x, y: u1.y - d*normal.y, z: u1.z - d*normal.z };
  const len = Math.hypot(u1.x,u1.y,u1.z)||1;
  u1 = { x:u1.x/len, y:u1.y/len, z:u1.z/len };
  const u2 = { x: normal.y*u1.z - normal.z*u1.y,
               y: normal.z*u1.x - normal.x*u1.z,
               z: normal.x*u1.y - normal.y*u1.x };

  const surfaceX=[], surfaceY=[], surfaceZ=[];
  const resolution=10;
  for (let i=0;i<resolution;i++){
    const rx=[], ry=[], rz=[];
    for (let j=0;j<resolution;j++){
      const s = (i/(resolution-1)-0.5)*2*planeSize;
      const t2 = (j/(resolution-1)-0.5)*2*planeSize;
      rx.push(s*u1.x + t2*u2.x);
      ry.push(s*u1.y + t2*u2.y);
      rz.push(s*u1.z + t2*u2.z);
    }
    surfaceX.push(rx); surfaceY.push(ry); surfaceZ.push(rz);
  }

  const surfaceTrace = {
    x: surfaceX, y: surfaceY, z: surfaceZ,
    type: 'surface', name: 'Projection Plane',
    colorscale: [[0, t.isDark ? 'rgba(16,185,129,0.25)' : 'rgba(0,200,0,0.25)'],
                 [1, t.isDark ? 'rgba(16,185,129,0.25)' : 'rgba(0,200,0,0.25)']],
    showscale: false, opacity: 0.6, hoverinfo: 'skip'
  };

  // Normal vector line
  const normalTrace = {
    x:[0, normal.x*2], y:[0, normal.y*2], z:[0, normal.z*2],
    mode:'lines', type:'scatter3d', name:'Normal Vector',
    line:{ color: '#ef4444', width: 6 }
  };

  // 2D scatter
  const trace2D = {
    x: projected.map(p=>p.x),
    y: projected.map(p=>p.y),
    mode:'markers', type:'scatter', name:'Projected Data',
    marker:{ size: 9, color: t.isDark ? '#f59e0b' : '#ff7f0e', opacity: 0.9 }
  };

  // PCA vectors (both 3D and 2D)
  const pcaTraces3D = [];
  const pcaTraces2D = [];
  if (document.getElementById('showPCA').checked) {
    const pca = calculatePCA(data3D);
    if (pca) {
      const scale = 2.8;
      function make3D(pc, name, color) {
        return {
          x: [pca.center.x - scale*pc.x, pca.center.x + scale*pc.x],
          y: [pca.center.y - scale*pc.y, pca.center.y + scale*pc.y],
          z: [pca.center.z - scale*pc.z, pca.center.z + scale*pc.z],
          mode: 'lines', type: 'scatter3d', name, line:{ color, width: 7 }
        };
      }
      function make2D(pc, name, color) {
        const endpoints = [
          {x:pca.center.x - scale*pc.x, y:pca.center.y - scale*pc.y, z:pca.center.z - scale*pc.z},
          {x:pca.center.x + scale*pc.x, y:pca.center.y + scale*pc.y, z:pca.center.z + scale*pc.z}
        ];
        const projEnds = projectTo2D(endpoints, normal);
        return {
          x: projEnds.map(p=>p.x),
          y: projEnds.map(p=>p.y),
          mode:'lines', type:'scatter', name, line:{ color, width: 4 }
        };
      }

      pcaTraces3D.push(make3D(pca.pc1, 'PC1', '#a855f7'));
      pcaTraces3D.push(make3D(pca.pc2, 'PC2', '#ec4899'));
      pcaTraces3D.push(make3D(pca.pc3, 'PC3', '#22d3ee'));

      pcaTraces2D.push(make2D(pca.pc1, 'PC1', '#a855f7'));
      pcaTraces2D.push(make2D(pca.pc2, 'PC2', '#ec4899'));
      pcaTraces2D.push(make2D(pca.pc3, 'PC3', '#22d3ee'));
    }
  }

  // Render 3D
  const layout3D = {
    scene: {
      bgcolor: t.plotBg,
      xaxis: {range: [-4, 4], title:'X', gridcolor:t.grid, zerolinecolor:t.grid, color:t.axis, showbackground:true, backgroundcolor:t.plotBg, fixedrange: true },
      yaxis: {range: [-4, 4], title:'Y', gridcolor:t.grid, zerolinecolor:t.grid, color:t.axis, showbackground:true, backgroundcolor:t.plotBg, fixedrange: true},
      zaxis: {range: [-4, 4], title:'Z', gridcolor:t.grid, zerolinecolor:t.grid, color:t.axis, showbackground:true, backgroundcolor:t.plotBg, fixedrange: true },
      aspectmode:'cube'
    },
      legend: {
    orientation: 'h',
    x: 0.5,
    xanchor: 'center',
    y: -0.2 // slightly below the plot
  },
    paper_bgcolor: t.paperBg,
    font: { color: t.text },
    margin: { l:0, r:0, t:0, b:0 }
  };
  const config3D = { staticPlot:false, displayModeBar:false };

  const traces3D = [trace3D, surfaceTrace, normalTrace, ...pcaTraces3D];
  Plotly.react('plot3d', traces3D, layout3D, config3D);

  // Render 2D
  const layout2D = {
    xaxis: { range:[-4,4], title:'Uâ‚', gridcolor:t.grid, zerolinecolor:t.grid, color:t.axis },
    yaxis: { range:[-4,4], title:'Uâ‚‚', scaleanchor:'x', scaleratio:1, gridcolor:t.grid, zerolinecolor:t.grid, color:t.axis },
      legend: {
    orientation: 'h',
    x: 0.5,
    xanchor: 'center',
    y: -0.2 // slightly below the plot
  },
    paper_bgcolor: t.paperBg,
    plot_bgcolor: t.plotBg,
    font: { color: t.text },
    margin: { l:50, r:20, t:20, b:50 }
  };
  const config2D = { staticPlot:false, displayModeBar:false };

  Plotly.react('plot2d', [trace2D, ...pcaTraces2D], layout2D, config2D);

  // Variance display (of projected points)
  document.getElementById('varianceValue').textContent = variance.toFixed(2);
}

/* ---------- Events ---------- */
document.getElementById('azimuthSlider').addEventListener('input', (e) => {
  azimuth = parseFloat(e.target.value);
  document.getElementById('azimuthValue').textContent = Math.round(azimuth) + 'Â°';
  updatePlots();
});
document.getElementById('elevationSlider').addEventListener('input', (e) => {
  elevation = parseFloat(e.target.value);
  document.getElementById('elevationValue').textContent = Math.round(elevation) + 'Â°';
  updatePlots();
});
document.getElementById('regenerateBtn').addEventListener('click', () => {
  data3D = generateData();
  updatePlots();
});
document.getElementById('pc12Btn').addEventListener('click', () => {
  const p = calculatePCA(data3D);
  if (p) setToPCPlane(p.pc1, p.pc2);
});
document.getElementById('pc13Btn').addEventListener('click', () => {
  const p = calculatePCA(data3D);
  if (p) setToPCPlane(p.pc1, p.pc3);
});
document.getElementById('pc23Btn').addEventListener('click', () => {
  const p = calculatePCA(data3D);
  if (p) setToPCPlane(p.pc2, p.pc3);
});
document.getElementById('showPCA').addEventListener('change', updatePlots);

/* ---------- Init ---------- */
setTimeout(updatePlots, 50);
</script>
</body>
</html>

